# [ Greedy, 탐욕법 ]

#### 설명 

그리디는 "매 선택에서 가장 좋은 것만"을 고르는 방법이다. 관찰을 통해 탐색 범위를 줄이는 방법이라고도 할 수 있다.  

매번 가장 좋은 것만 고른다면 항상은 아니지만 **어느 정도** 최적의 해에 근사한 값을 빠르게 구할 수 있다는 장점이 있다. 그러나 그 말인 즉, 확실한 최적의 해를 **보장할 수 없을 때도 많다**는 것이다.



#### 진행 순서

> 단순히 **"현재 상황에서 가장 좋아 보이는 것만을 반복적으로 선택해도"** 최적의 해를 구할 수 있는 지를 검토하는 것이 중요하다. 따라서 그리디를 적용하는 흐름은 다음과 같다.

+ 문제 해결을 위한 아이디어를 (직관적으로) 추론해낸다.

+ 그 아이디어가 정당한지, 반례는 없는지 논리적(수학적)으로 입증 한다.



#### 예시

+ [BOJ 1931] 회의실 배정 문제  

한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

+ 문제 해결 흐름

1. 회의 시작 시간, 회의 종료 시간, 회의 진행 시간 등의 조건 중에서 어떤 방법이 가장 좋을지 추론한다.
2. 회의 종료 시간이 빠른 순으로 정렬했을 때 가장 많은 회의를 진행할 수 있을 것 같다.
3. 귀류법을 사용해 이 명제를 증명할 수 있다. 혹은 다른 방법의 반례를 찾을 수 있다.
   ex. 회의 시작 시간이 빨라도 진행 시간이 길면, 늦게 시작해도 짧게 끝나는 회의 여러 개가 있을 때 더 많은 회의를 진행할 수 있다. 또한 회의 진행 시간이 짧아도 서로 겹치지 않는 두 회의의 진행 시간 사이에 껴 있으면 두 개를 진행할 수 있는 걸 하나밖에 진행할 수 없다.
4. 따라서 종료 시간이 빠른 순으로 정렬한다. 단, 시작하자마다 끝나는 회의가 존재한다는 조건이 있으니 종료 시간이 같을 경우, 시작 시간이 빠른 순으로 정렬한다.
5. 회의 시작 시간이 앞선 회의의 종료 시간보다 같거나 늦은 회의 중, 가장 먼저 시작하는 회의를 카운트 한다.

```javascript
function solution(meeting) {
    let answer = 0;
    meeting.sort((a, b) => {
        if(a[1] === b[1]) return a[0]-b[0];
        else return a[1]-b[1];
    })
    
    let end_time = 0;
    for(let x of meeting) {
        if(x[0] >= end_time) {
            answer++;
            end_time = x[1];
        }
    }
    return answer;
}

// [회의 시작시간, 회의 종료시간] 
let arr=[[1, 4], [2, 3], [3, 5], [4, 6], [5, 7]];
console.log(solution(arr));
```



#### 참고

[[바킹독의 실전 알고리즘] 0x11강 - 그리디](https://www.youtube.com/watch?v=De0Qg-2O80c&t=306s)

[2. 그리디 & 구현](https://www.youtube.com/watch?v=2zjoKjt97vQ)