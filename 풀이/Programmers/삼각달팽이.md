### 문제

+ 프로그래머스 > 월간 코드 챌린지 시즌1 > 삼각 달팽이
+ **규칙 찾기**
+ [링크](https://programmers.co.kr/learn/courses/30/lessons/68645)

별 찍기 류의 문제와 유사하게 어떤 규칙에 따라 반복을 할 지를 찾아내는 것이 핵심인 문제다.

알듯말듯하지만 결국 해결하지 못하였다.

규칙을 찾는 문제에 특히 약간 것 같은데, 눈에 보이는 규칙을 손으로 써보면서 식을 완성하는 습관을 기르면 도움이 될 것 같다.



### 풀이

예시를 통해 찾아낸 규칙은 다음과 같다.

+ 먼저 가장 바깥 쪽의 삼각형의 좌변이 0행에서부터 n-1행까지 1씩 증가하며 n개를 채운다.
+ 다음으로 밑변이 왼쪽에서부터 오른쪽으로 1씩 증가하며 n-1개 채워진다.
+ 마지막으로 우변이 밑에서부터 위로 1씩 증가하며 n-2개 채워지면 가장 외곽 삼각형이 완성된다.
+ 두 번째 삼각형의 좌변은 n-3개를 채우는 것으로 시작하여 위의 과정을 반복한다.
+ n이 0이 되면 삼각형의 모든 공간이 채워진다.

삼각형의 숫자가 채워지는 순서가 위와 같다면, 배열에 숫자를 채우는 규칙은 다음과 같다.

+ 삼각형은 0행부터 n-1행까지, 총 n개의 행으로 이루어져 있다.
+ 가장 윗 행의 길이는 1이며 아래로 갈수록 행의 길이는 1씩 증가한다.
+ 각 행의 0열을 먼저 채우고,
+ 가장 아래 행의 1열부터 마지막 열을 채운 뒤,
+ 바로 윗 행부터 위로 올라가며 마지막 열을 채운다.
+ 변이 바뀔 때마다 채워야하는 숫자의 개수가 한 개씩 줄어든다.



위의 규칙을 차근차근 코드로 풀어내보자.

```javascript
function solution(n) {
    let answer = Array.from({length:n}, (_,i)=>Array(i+1));
    let num = 0;
    let x = -1;
    let y = 0;
    
    // n이 0이 되면 삼각형이 전부 채워진다.
    while(n) {
        // 좌변 채우기
        for(let i=0; i<n; i++) answer[++x][y] = ++num;
        // 밑변 채우기
        for(let i=0; i<n-1; i++) answer[x][++y] = ++num;
        // 우변 채우기
        for(let i=0; i<n-2; i++) answer[--x][--y] = ++num;
        // 삼각형 하나가 완성되면 다음 삼각형의 좌변은 n-3개부터 시작
        n -= 3; 
    }  
    
	return answer.flatmap(e => e);
}
```

주의해야 할 점은,

**x는 -1로 시작한다는 점**, map 메서드와 비슷하지만 요소를 1단계 평단화하여 반환해주는 **flatmap() 메서드**를 활용하여 정답을 반환하는 것이다.



삼각형이 채워지는 확실한 규칙만 찾는다면, 다양한 방법으로 구현할 수 있다.

```javascript
function solution(n) {
    let answer = Array.from({length:n}, (_,i)=>Array(i+1));
    let num = 0;
    let x = -1;
    let y = 0;
    
    for(let i=0; i<n; i++) {
        // 변을 채우는 숫자의 개수가 하나씩 줄어든다.
    	for(let j=i; i<n; j++) {
            // 좌변 순서일 때
            if(i % 3 === 0) x++;
            // 밑변 순서일 때
            else if(i % 3 === 1) y++;
            // 우변 순서일 때
            else {
                x--;
                y--;
            }
            answer[x][y] = ++num;
        }    
    }
    
	return answer.flatmap(e => e);
}
```

좌변 -> 밑변 -> 우변 순서가 반복되기 때문에 3으로 나눈 나머지로 어느 변의 차례인지를 판별하고,

하나의 변이 채워질 때마다 채워야할 숫자의 개수(n)도 하나씩 줄어든다.  

따라서 i가 n-1일 때 j는 n-1이므로, 마지막 한 개의 숫자가 채워지고 끝나는 풀이다.